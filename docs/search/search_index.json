{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Project Chameleon \u00b6 Discovering a new relocation entry of ARM64X in recent Windows 10 on Arm Relock 3.0: Relocation-based obfuscation revisited in Windows 11 on Arm Author \u00b6 Koh M. Nakagawa. \u00a9 FFRI Security, Inc. 2021","title":"Top page"},{"location":"#project-chameleon","text":"Discovering a new relocation entry of ARM64X in recent Windows 10 on Arm Relock 3.0: Relocation-based obfuscation revisited in Windows 11 on Arm","title":"Project Chameleon"},{"location":"#author","text":"Koh M. Nakagawa. \u00a9 FFRI Security, Inc. 2021","title":"Author"},{"location":"arm64x_reloc_obfuscation/","text":"Relock 3.0: Relocation-based obfuscation revisited in Windows 11 on Arm \u00b6 Date: 2021/10/29 Author: Koh M. Nakagawa Introduction \u00b6 My previous post introduced a new relocation entry for ARM64X: IMAGE_DYNAMIC_RELOCATION_ARM64X , where I explained how this relocation entry allows ARM64X to behave as ARM64 and ARM64EC binaries. Please refer to this post if you have not read it. According to a tweet from a Microsoft developer, the ARM64X binary has been called a \"chameleon binary\" instead of a fat binary. ARM64X is a binary code that changes its architecture depending on its surroundings. Therefore, they named it chameleon, owing to its ability to change color to match its surroundings. In my previous post, I explained that IMAGE_DYNAMIC_RELOCATION_ARM64X has three relocation entries. Zero fill Assign value Delta Of these, the relocation entry \"assign value\" is particularly interesting. Unlike IMAGE_REL_BASED_HIGHLOW , which is a well-known relocation entry, \"assign value\" allows arbitrary addresses to be overwritten with arbitrary values. Because this \"assign value\" relocation entry enables flexible and dynamic binary rewriting, can it not be abused? This post describes an obfuscation technique that exploits IMAGE_DYNAMIC_RELOCATION_ARM64X in ARM64X. In the following, IMAGE_DYNAMIC_RELOCATION_ARM64X is referred to as DVRT ARM64X because this relocation entry is a Dynamic Value Relocation Table (DVRT) introduced in ARM64X. Related works \u00b6 Relocation-based obfuscation techniques have been known for a long time. First, I will briefly explain the well-known base relocation entry ( IMAGE_REL_BASED_HIGHLOW ) and the relocation-based obfuscation technique that exploits it. Base relocation \u00b6 First, let us briefly review the relocation process in Windows. In the recent version of Windows, ASLR has been enabled in most system modules; therefore, the value of the image base set at runtime is usually different from the value of BaseOfCode in the PE header. In this post, the value of BaseOfCode described in the PE header is denoted as \"desired base\" for clarity. If the code is executed when the desired base is different from the image base, an error will occur in executing instructions specifying an absolute address. For example, consider the following code that prints a string in the .data section for standard output. push 0x403018 # a pointer to a string push 0x402100 # \"%s\\n\" call _printf # printf(\"%s\\n\", \"Hello\") As shown above, the data contained in the .data section is specified as an absolute address (such as 0x403018 and 0x402100). This absolute address is for the case where the image base is set to the desired base (0x400000). Therefore, unintended data access will occur when the image base is different from the desired base owing to ASLR. A program loader solves this problem by dynamically patching the executable at runtime to work on the new image base, which is called the relocation process. The following pseudo-code illustrates how the relocation is applied. // Listing 1 // The following pseudo code is from https://media.defcon.org/DEF%20CON%2026/DEF%20CON%2026%20presentations/DEFCON-26-Nick-Cano-Relocation-Bonus-Attacking-the-Win-Loader.pdf auto delta = imageBase - desiredBase ; for ( auto reloc : relocs ) { auto block = ( base + reloc . VirtualAddress ); for ( auto entry : reloc . entries ) { auto adr = block + entry . offset ; // apply patch to the image if ( entry . type == IMAGE_REL_BASED_HIGHLOW ) * (( uint32_t * ) adr ) += delta ; else if ( entry . type == IMAGE_REL_BASED_DIR64 ) * (( uint64_t * ) adr ) += delta ; else if ( entry . type == IMAGE_REL_BASED_HIGH ) * (( uint16_t * ) adr ) += ( uint16_t )(( delta >> 16 ) & 0xFFFF ); else if ( entry . type == IMAGE_REL_BASED_LOW ) * (( uint16_t * ) adr ) += ( uint16_t ) delta ; } } In the relocation process, delta (the subtraction of the desired base from the image base) value is added to the instruction operand containing the absolute address. After the relocation process, the absolute addresses are fixed to work in the new image base. There are several types of relocations ( IMAGE_REL_BASED_HIGHLOW , IMAGE_REL_BASED_DIR64 , IMAGE_REL_BASED_HIGH , and IMAGE_REL_BASED_LOW ), and patches differ depending on the relocation type. Some relocations are disabled in recent Windows (for example, IMAGE_REL_BASED_HIGH is no longer supported). Next, I introduce the previous studies of relocation-based obfuscation. \"Relock-based vulnerability in Windows 7\" (Virus Bulletin 2011) \u00b6 This research explains relocation-based obfuscation in Windows XP/2000 and Windows 7. The idea is simple; we can extract the payload at runtime by exploiting the relocation process as a decoder. So, we can encrypt the data in the executable file (e.g., code in the .text section), then extract the payload at runtime by the dynamic patch of the relocation process. As can be seen from the code above (Listing 1), when the relocation process is used as a decoder, the ability to control the value of delta is essential. In this research, the authors use the vulnerability in the Windows loader to control the delta value. Specifically, the following two vulnerabilities were used: Windows XP/2000: When the desired base is set to 0, the image base at runtime is automatically set to 0x10000. Windows 7: When the desired base is set to 0X7FFE0000 or higher, the runtime image base is automatically set to 0x10000. For Windows XP/2000, a method was proposed to exploit the IMAGE_REL_BASED_HIGH . This obfuscation technique was used to obfuscate the W32/Relock malware. However, IMAGE_REL_BASED_HIGH is no longer available on Windows 7. Instead, a method using IMAGE_REL_BASED_HIGHLOW has been proposed, and this method is called Relock 2.0 in their research article. \"Relocation Bonus Attacking the Windows Loader Makes Analysts Switch Careers\" (DEF CON 26) \u00b6 This presentation describes the relocation-based obfuscation available in Windows 7 and Windows 10. The method used for Windows 7 is the same as that described in the previous section . This presentation is novel in that it proposes a new method for Windows 10. Since the vulnerability described in the previous section was fixed in Windows 10, the delta could no longer be controlled. The author solved this problem by repeating the execution until the image base value becomes a specific value. Relocation-based obfuscation by DVRT ARM64X \u00b6 As mentioned in the introduction , the DVRT ARM64X relocation enables an arbitrary write in the target module. By abusing DVRT ARM64X, we can obfuscate an executable in the same manner as described in the previous section (Figure 1). Figure 1 Relocation-based obfuscation by DVRT ARM64X Let me show an example to obfuscate some code in .text using DVRT ARM64X. An executable demonstrated in this section can be created using this tool . Figure 2 shows the contents of the obfuscated executable's code section. The junk data are placed in the code section (Figure 2). Figure 2 Code section content (static) Of course, this code cannot be executed in its current form. So, we need to overwrite the code section with a dynamic patch using \"assign value\" relocation of DVRT ARM64X. By adding the \"assign value\" relocation entries of DVRT ARM64X and exploiting these dynamic patches, we can expand the following code and execute it at runtime (Figure 3). Figure 3 Code section content (dynamic) Additionally, by changing the PE Header's contents, it is possible to change the contents of the IAT and EAT to something else. This makes it possible to cheat the results of the static analysis tools. In contrast to the previous studies described in related works , we can not only change the contents of IATs and EATs to junk data but also change them and display fake IATs and EATs. Remember that the DVRT ARM64X is different from conventional relocation entries in that it can enable the arbitrary write in the target module. Therefore, it is possible to make the file appear to be an unobfuscated executable. Further techniques to make analysis more difficult \u00b6 You might think that this obfuscation technique can be easily analyzed by dumping the executable on the memory. Is it possible to make the analysis even more difficult? In the following section, I introduce some ideas to make the analysis more difficult. Section Header Modification \u00b6 The result of the memory dump is usually analyzed by a disassembler such as Ghidra. A disassembler determines where to map each section from the PE Section Header. What will happen if a part of this section header is NULL? Consider the following program. Compile it and save it as \"TestSectionHeader.exe.\" // Listing 2 // Compile and save as \"TestSectionHeader.exe\" #include <iostream> #pragma code_seg(\".sect1\") void hoge () { std :: puts ( \"hoge\" ); } int main () { hoge (); } In the above source code, #pragma code_seg(\".sect1\") is added. This pragma creates a new code section called .sect1 in addition to the default .text section (Figure 4). The code for the hoge function and the main function are placed in .sect1 . Figure 4 Sections of \"TestSectionHeader.exe\" executable Next, edit the image section header in Ghidra and set most of the fields in the entry corresponding to .sect1 to NULL (Figure 5). Figure 5 Listing view of the image section header Then, reopen the same executable and you will see the following. Figure 6 Sections of \"TestSectionHeader.exe\" executable after the modification of the Image Section Header You can see that .sect1 is not listed in the Program Tree. By using this property and setting the RVA of the section header to be hidden by DVRT ARM64X to NULL at runtime, we can make its analysis difficult after the memory dump. The value of RVA can also be specified in another section as its value. This makes analysis difficult because the contents of another section are displayed when it is opened with a disassembler. Fooling WinDbg \u00b6 Next, I introduce a method to make it difficult to analyze extracted code with WinDbg. Before explaining this, let me explain the Hybrid Code Map. Recall that ARM64X contains the code for three architectures: ARM64, ARM64EC, and x64. Hybrid Code Map is a structure that manages the location of an architecture's code in the addresses. The following is the result of outputting the contents of the Hybrid Code Map using dumpbin. > dumpbin /LOADCONFIG KernelBase.dll ... Hybrid Code Address Range Table Address Range ---------------------- x64 0000000180001000 - 000000018000835F (00001000 - 0000835F) arm64 0000000180009000 - 00000001801111CB (00009000 - 001111CB) arm64ec 0000000180112000 - 0000000180227117 (00112000 - 00227117) x64 0000000180228000 - 000000018022A001 (00228000 - 0022A001) If the process is ARM64EC, the area marked as x64 and ARM64EC in the Hybrid Code Map is executed, and the area marked as ARM64 is not used. WinDbg changes the machine architecture in the disassembly view depending on which code (x64 or ARM64EC) is executed. WinDbg probably uses the Hybrid Code Map information to determine the machine architecture. Now, the ARM64EC process does not execute ARM64 code in ARM64X, but what would happen if we moved the program counter the ARM64 code in ARM64X? We can observe an interesting behavior. Figure 7 PoC movie of fooling WinDbg disassembly Look at the gif above. b instruction makes a transition to the code in the area marked as ARM64. After the transition, the disassembly result is ??? , indicating that it could not be correctly disassembled. However, we can observe that the step execution can be continued! The code at the destination address of the b is actually the shellcode of x64 calling MessageBoxA as shown below. 0 x00000000 33 c0 xor eax , eax 0 x00000002 4 c8bca mov r9 , rdx 0 x00000005 4 c8bd1 mov r10 , rcx 0 x00000008 4885 d2 test rdx , rdx 0 x0000000b 0 f8491000000 je 0xa2 0 x00000011 450 fb602 movzx r8d , byte [ r10 ] 0 x00000015 4 d8d5201 lea r10 , [ r10 + 1 ] 0 x00000019 4183 c820 or r8d , 0x20 0 x0000001d 4133 c0 xor eax , r8d 0 x00000020 8 bd0 mov edx , eax 0 x00000022 d1e8 shr eax , 1 0 x00000024 83 e201 and edx , 1 0 x00000027 69 ca783bf682 imul ecx , edx , 0x82f63b78 0 x0000002d 33 c8 xor ecx , eax 0 x0000002f 8 bc1 mov eax , ecx 0 x00000031 d1e9 shr ecx , 1 0 x00000033 83 e001 and eax , 1 0 x00000036 69 d0783bf682 imul edx , eax , 0x82f63b78 0 x0000003c 33 d1 xor edx , ecx 0 x0000003e 8 bc2 mov eax , edx 0 x00000040 d1ea shr edx , 1 0 x00000042 83 e001 and eax , 1 0 x00000045 69 c8783bf682 imul ecx , eax , 0x82f63b78 0 x0000004b 33 ca xor ecx , edx 0 x0000004d 8 bc1 mov eax , ecx 0 x0000004f d1e9 shr ecx , 1 0 x00000051 83 e001 and eax , 1 0 x00000054 69 d0783bf682 imul edx , eax , 0x82f63b78 0 x0000005a 33 d1 xor edx , ecx 0 x0000005c 8 bc2 mov eax , edx 0 x0000005e d1ea shr edx , 1 0 x00000060 83 e001 and eax , 1 0 x00000063 69 c8783bf682 imul ecx , eax , 0x82f63b78 0 x00000069 33 ca xor ecx , edx 0 x0000006b 8 bc1 mov eax , ecx 0 x0000006d d1e9 shr ecx , 1 0 x0000006f 83 e001 and eax , 1 0 x00000072 69 d0783bf682 imul edx , eax , 0x82f63b78 0 x00000078 33 d1 xor edx , ecx 0 x0000007a 8 bc2 mov eax , edx 0 x0000007c d1ea shr edx , 1 0 x0000007e 83 e001 and eax , 1 0 x00000081 69 c8783bf682 imul ecx , eax , 0x82f63b78 0 x00000087 33 ca xor ecx , edx 0 x00000089 8 bc1 mov eax , ecx 0 x0000008b d1e9 shr ecx , 1 0 x0000008d 83 e001 and eax , 1 0 x00000090 69 c0783bf682 imul eax , eax , 0x82f63b78 0 x00000096 33 c1 xor eax , ecx 0 x00000098 4983 e901 sub r9 , 1 0 x0000009c 0 f856fffffff jne 0x11 0 x000000a2 c3 ret Although the exact cause is unknown, the ARM64 code regions are interpreted and executed as x64 code in the ARM64EC process. However, WinDbg refers to the Hybrid Code Map and disassembles as ARM64. Therefore, although the code can be executed, the disassembly view will be invalid. Side Effect: Parent-process-dependent code execution \u00b6 Finally, I would like to mention the side effect of the DVRT ARM64X relocation-based obfuscation. Recall that DVRT ARM64X relocation is only applied when ARM64X is executed as an ARM64EC or x64 process. The relocation is not applied if it is run as an ARM64 process. For ARM64X DLLs, DVRT ARM64X is applied when ARM64EC or x64 processes use them. However, what about ARM64X EXEs? Longhorn examined this, and the following table summarizes the results obtained by him. For ARM64X EXEs, the executed code in ARM64X depends on the parent process that runs it. Architecture of parent process Architecture of executed code x86 ARM64 x64 ARM64EC ARM64 ARM64 ARM64EC ARM64EC DVRT ARM64X relocation is applied only when the parent process architecture is ARM64EC or x64. This means that if the parent process architecture is x86 or ARM64, DVRT ARM64X relocation is not applied, and the ARM64 code in ARM64X is executed. Thus, ARM64X is a binary with different execution results depending on the architecture from which the parent process runs. This property can be exploited by attackers. For example, let us consider analyzing the ARM64X binary in a sandbox environment. ARM64X PE appears to be ARM64 PE through a simple static analysis (e.g., file type check by UNIX file command). Therefore, if you do not identify ARM64X, you might run it as an ARM64 PE and obtain the result of the dynamic analysis (despite the fact that ARM64EC actually contains malicious code!). When scrutinizing the results of dynamic analysis, it is necessary to check not only to look the results when running as an ARM64 but also the results when running as an ARM64EC. Conclusion \u00b6 In this article, we proposed the relocation-based obfuscation technique using DVRT ARM64X. As explained, relocation-based obfuscation techniques have been known for a long time. However, these techniques are now almost unusable because they rely on the image loader vulnerabilities that are currently fixed. With the introduction of DVRT ARM64X in Windows on ARM, relocation-based obfuscation can be used again for practical use. Since this technique does not rely on the vulnerabilities of the image loader, the proposed method can be used in Windows on ARM for a long time. I have also presented ideas to make the analysis of ARM64X more complicated and a side effect of the dependency of execution results on the parent process. Although some of these are not directly related to relocation-based obfuscation, they can be combined with the DVRT ARM64X obfuscation method to make analysis more difficult. Microsoft has not yet officially documented ARM64X, and there are not many reverse engineering results. Further research is required in this regard.","title":"Relock 3.0: Relocation-based obfuscation revisited in Windows 11 on Arm"},{"location":"arm64x_reloc_obfuscation/#relock-30-relocation-based-obfuscation-revisited-in-windows-11-on-arm","text":"Date: 2021/10/29 Author: Koh M. Nakagawa","title":"Relock 3.0: Relocation-based obfuscation revisited in Windows 11 on Arm"},{"location":"arm64x_reloc_obfuscation/#introduction","text":"My previous post introduced a new relocation entry for ARM64X: IMAGE_DYNAMIC_RELOCATION_ARM64X , where I explained how this relocation entry allows ARM64X to behave as ARM64 and ARM64EC binaries. Please refer to this post if you have not read it. According to a tweet from a Microsoft developer, the ARM64X binary has been called a \"chameleon binary\" instead of a fat binary. ARM64X is a binary code that changes its architecture depending on its surroundings. Therefore, they named it chameleon, owing to its ability to change color to match its surroundings. In my previous post, I explained that IMAGE_DYNAMIC_RELOCATION_ARM64X has three relocation entries. Zero fill Assign value Delta Of these, the relocation entry \"assign value\" is particularly interesting. Unlike IMAGE_REL_BASED_HIGHLOW , which is a well-known relocation entry, \"assign value\" allows arbitrary addresses to be overwritten with arbitrary values. Because this \"assign value\" relocation entry enables flexible and dynamic binary rewriting, can it not be abused? This post describes an obfuscation technique that exploits IMAGE_DYNAMIC_RELOCATION_ARM64X in ARM64X. In the following, IMAGE_DYNAMIC_RELOCATION_ARM64X is referred to as DVRT ARM64X because this relocation entry is a Dynamic Value Relocation Table (DVRT) introduced in ARM64X.","title":"Introduction"},{"location":"arm64x_reloc_obfuscation/#related-works","text":"Relocation-based obfuscation techniques have been known for a long time. First, I will briefly explain the well-known base relocation entry ( IMAGE_REL_BASED_HIGHLOW ) and the relocation-based obfuscation technique that exploits it.","title":"Related works"},{"location":"arm64x_reloc_obfuscation/#base-relocation","text":"First, let us briefly review the relocation process in Windows. In the recent version of Windows, ASLR has been enabled in most system modules; therefore, the value of the image base set at runtime is usually different from the value of BaseOfCode in the PE header. In this post, the value of BaseOfCode described in the PE header is denoted as \"desired base\" for clarity. If the code is executed when the desired base is different from the image base, an error will occur in executing instructions specifying an absolute address. For example, consider the following code that prints a string in the .data section for standard output. push 0x403018 # a pointer to a string push 0x402100 # \"%s\\n\" call _printf # printf(\"%s\\n\", \"Hello\") As shown above, the data contained in the .data section is specified as an absolute address (such as 0x403018 and 0x402100). This absolute address is for the case where the image base is set to the desired base (0x400000). Therefore, unintended data access will occur when the image base is different from the desired base owing to ASLR. A program loader solves this problem by dynamically patching the executable at runtime to work on the new image base, which is called the relocation process. The following pseudo-code illustrates how the relocation is applied. // Listing 1 // The following pseudo code is from https://media.defcon.org/DEF%20CON%2026/DEF%20CON%2026%20presentations/DEFCON-26-Nick-Cano-Relocation-Bonus-Attacking-the-Win-Loader.pdf auto delta = imageBase - desiredBase ; for ( auto reloc : relocs ) { auto block = ( base + reloc . VirtualAddress ); for ( auto entry : reloc . entries ) { auto adr = block + entry . offset ; // apply patch to the image if ( entry . type == IMAGE_REL_BASED_HIGHLOW ) * (( uint32_t * ) adr ) += delta ; else if ( entry . type == IMAGE_REL_BASED_DIR64 ) * (( uint64_t * ) adr ) += delta ; else if ( entry . type == IMAGE_REL_BASED_HIGH ) * (( uint16_t * ) adr ) += ( uint16_t )(( delta >> 16 ) & 0xFFFF ); else if ( entry . type == IMAGE_REL_BASED_LOW ) * (( uint16_t * ) adr ) += ( uint16_t ) delta ; } } In the relocation process, delta (the subtraction of the desired base from the image base) value is added to the instruction operand containing the absolute address. After the relocation process, the absolute addresses are fixed to work in the new image base. There are several types of relocations ( IMAGE_REL_BASED_HIGHLOW , IMAGE_REL_BASED_DIR64 , IMAGE_REL_BASED_HIGH , and IMAGE_REL_BASED_LOW ), and patches differ depending on the relocation type. Some relocations are disabled in recent Windows (for example, IMAGE_REL_BASED_HIGH is no longer supported). Next, I introduce the previous studies of relocation-based obfuscation.","title":"Base relocation"},{"location":"arm64x_reloc_obfuscation/#relock-based-vulnerability-in-windows-7-virus-bulletin-2011","text":"This research explains relocation-based obfuscation in Windows XP/2000 and Windows 7. The idea is simple; we can extract the payload at runtime by exploiting the relocation process as a decoder. So, we can encrypt the data in the executable file (e.g., code in the .text section), then extract the payload at runtime by the dynamic patch of the relocation process. As can be seen from the code above (Listing 1), when the relocation process is used as a decoder, the ability to control the value of delta is essential. In this research, the authors use the vulnerability in the Windows loader to control the delta value. Specifically, the following two vulnerabilities were used: Windows XP/2000: When the desired base is set to 0, the image base at runtime is automatically set to 0x10000. Windows 7: When the desired base is set to 0X7FFE0000 or higher, the runtime image base is automatically set to 0x10000. For Windows XP/2000, a method was proposed to exploit the IMAGE_REL_BASED_HIGH . This obfuscation technique was used to obfuscate the W32/Relock malware. However, IMAGE_REL_BASED_HIGH is no longer available on Windows 7. Instead, a method using IMAGE_REL_BASED_HIGHLOW has been proposed, and this method is called Relock 2.0 in their research article.","title":"\"Relock-based vulnerability in Windows 7\" (Virus Bulletin 2011)"},{"location":"arm64x_reloc_obfuscation/#relocation-bonus-attacking-the-windows-loader-makes-analysts-switch-careers-def-con-26","text":"This presentation describes the relocation-based obfuscation available in Windows 7 and Windows 10. The method used for Windows 7 is the same as that described in the previous section . This presentation is novel in that it proposes a new method for Windows 10. Since the vulnerability described in the previous section was fixed in Windows 10, the delta could no longer be controlled. The author solved this problem by repeating the execution until the image base value becomes a specific value.","title":"\"Relocation Bonus Attacking the Windows Loader Makes Analysts Switch Careers\" (DEF CON 26)"},{"location":"arm64x_reloc_obfuscation/#relocation-based-obfuscation-by-dvrt-arm64x","text":"As mentioned in the introduction , the DVRT ARM64X relocation enables an arbitrary write in the target module. By abusing DVRT ARM64X, we can obfuscate an executable in the same manner as described in the previous section (Figure 1). Figure 1 Relocation-based obfuscation by DVRT ARM64X Let me show an example to obfuscate some code in .text using DVRT ARM64X. An executable demonstrated in this section can be created using this tool . Figure 2 shows the contents of the obfuscated executable's code section. The junk data are placed in the code section (Figure 2). Figure 2 Code section content (static) Of course, this code cannot be executed in its current form. So, we need to overwrite the code section with a dynamic patch using \"assign value\" relocation of DVRT ARM64X. By adding the \"assign value\" relocation entries of DVRT ARM64X and exploiting these dynamic patches, we can expand the following code and execute it at runtime (Figure 3). Figure 3 Code section content (dynamic) Additionally, by changing the PE Header's contents, it is possible to change the contents of the IAT and EAT to something else. This makes it possible to cheat the results of the static analysis tools. In contrast to the previous studies described in related works , we can not only change the contents of IATs and EATs to junk data but also change them and display fake IATs and EATs. Remember that the DVRT ARM64X is different from conventional relocation entries in that it can enable the arbitrary write in the target module. Therefore, it is possible to make the file appear to be an unobfuscated executable.","title":"Relocation-based obfuscation by DVRT ARM64X"},{"location":"arm64x_reloc_obfuscation/#further-techniques-to-make-analysis-more-difficult","text":"You might think that this obfuscation technique can be easily analyzed by dumping the executable on the memory. Is it possible to make the analysis even more difficult? In the following section, I introduce some ideas to make the analysis more difficult.","title":"Further techniques to make analysis more difficult"},{"location":"arm64x_reloc_obfuscation/#section-header-modification","text":"The result of the memory dump is usually analyzed by a disassembler such as Ghidra. A disassembler determines where to map each section from the PE Section Header. What will happen if a part of this section header is NULL? Consider the following program. Compile it and save it as \"TestSectionHeader.exe.\" // Listing 2 // Compile and save as \"TestSectionHeader.exe\" #include <iostream> #pragma code_seg(\".sect1\") void hoge () { std :: puts ( \"hoge\" ); } int main () { hoge (); } In the above source code, #pragma code_seg(\".sect1\") is added. This pragma creates a new code section called .sect1 in addition to the default .text section (Figure 4). The code for the hoge function and the main function are placed in .sect1 . Figure 4 Sections of \"TestSectionHeader.exe\" executable Next, edit the image section header in Ghidra and set most of the fields in the entry corresponding to .sect1 to NULL (Figure 5). Figure 5 Listing view of the image section header Then, reopen the same executable and you will see the following. Figure 6 Sections of \"TestSectionHeader.exe\" executable after the modification of the Image Section Header You can see that .sect1 is not listed in the Program Tree. By using this property and setting the RVA of the section header to be hidden by DVRT ARM64X to NULL at runtime, we can make its analysis difficult after the memory dump. The value of RVA can also be specified in another section as its value. This makes analysis difficult because the contents of another section are displayed when it is opened with a disassembler.","title":"Section Header Modification"},{"location":"arm64x_reloc_obfuscation/#fooling-windbg","text":"Next, I introduce a method to make it difficult to analyze extracted code with WinDbg. Before explaining this, let me explain the Hybrid Code Map. Recall that ARM64X contains the code for three architectures: ARM64, ARM64EC, and x64. Hybrid Code Map is a structure that manages the location of an architecture's code in the addresses. The following is the result of outputting the contents of the Hybrid Code Map using dumpbin. > dumpbin /LOADCONFIG KernelBase.dll ... Hybrid Code Address Range Table Address Range ---------------------- x64 0000000180001000 - 000000018000835F (00001000 - 0000835F) arm64 0000000180009000 - 00000001801111CB (00009000 - 001111CB) arm64ec 0000000180112000 - 0000000180227117 (00112000 - 00227117) x64 0000000180228000 - 000000018022A001 (00228000 - 0022A001) If the process is ARM64EC, the area marked as x64 and ARM64EC in the Hybrid Code Map is executed, and the area marked as ARM64 is not used. WinDbg changes the machine architecture in the disassembly view depending on which code (x64 or ARM64EC) is executed. WinDbg probably uses the Hybrid Code Map information to determine the machine architecture. Now, the ARM64EC process does not execute ARM64 code in ARM64X, but what would happen if we moved the program counter the ARM64 code in ARM64X? We can observe an interesting behavior. Figure 7 PoC movie of fooling WinDbg disassembly Look at the gif above. b instruction makes a transition to the code in the area marked as ARM64. After the transition, the disassembly result is ??? , indicating that it could not be correctly disassembled. However, we can observe that the step execution can be continued! The code at the destination address of the b is actually the shellcode of x64 calling MessageBoxA as shown below. 0 x00000000 33 c0 xor eax , eax 0 x00000002 4 c8bca mov r9 , rdx 0 x00000005 4 c8bd1 mov r10 , rcx 0 x00000008 4885 d2 test rdx , rdx 0 x0000000b 0 f8491000000 je 0xa2 0 x00000011 450 fb602 movzx r8d , byte [ r10 ] 0 x00000015 4 d8d5201 lea r10 , [ r10 + 1 ] 0 x00000019 4183 c820 or r8d , 0x20 0 x0000001d 4133 c0 xor eax , r8d 0 x00000020 8 bd0 mov edx , eax 0 x00000022 d1e8 shr eax , 1 0 x00000024 83 e201 and edx , 1 0 x00000027 69 ca783bf682 imul ecx , edx , 0x82f63b78 0 x0000002d 33 c8 xor ecx , eax 0 x0000002f 8 bc1 mov eax , ecx 0 x00000031 d1e9 shr ecx , 1 0 x00000033 83 e001 and eax , 1 0 x00000036 69 d0783bf682 imul edx , eax , 0x82f63b78 0 x0000003c 33 d1 xor edx , ecx 0 x0000003e 8 bc2 mov eax , edx 0 x00000040 d1ea shr edx , 1 0 x00000042 83 e001 and eax , 1 0 x00000045 69 c8783bf682 imul ecx , eax , 0x82f63b78 0 x0000004b 33 ca xor ecx , edx 0 x0000004d 8 bc1 mov eax , ecx 0 x0000004f d1e9 shr ecx , 1 0 x00000051 83 e001 and eax , 1 0 x00000054 69 d0783bf682 imul edx , eax , 0x82f63b78 0 x0000005a 33 d1 xor edx , ecx 0 x0000005c 8 bc2 mov eax , edx 0 x0000005e d1ea shr edx , 1 0 x00000060 83 e001 and eax , 1 0 x00000063 69 c8783bf682 imul ecx , eax , 0x82f63b78 0 x00000069 33 ca xor ecx , edx 0 x0000006b 8 bc1 mov eax , ecx 0 x0000006d d1e9 shr ecx , 1 0 x0000006f 83 e001 and eax , 1 0 x00000072 69 d0783bf682 imul edx , eax , 0x82f63b78 0 x00000078 33 d1 xor edx , ecx 0 x0000007a 8 bc2 mov eax , edx 0 x0000007c d1ea shr edx , 1 0 x0000007e 83 e001 and eax , 1 0 x00000081 69 c8783bf682 imul ecx , eax , 0x82f63b78 0 x00000087 33 ca xor ecx , edx 0 x00000089 8 bc1 mov eax , ecx 0 x0000008b d1e9 shr ecx , 1 0 x0000008d 83 e001 and eax , 1 0 x00000090 69 c0783bf682 imul eax , eax , 0x82f63b78 0 x00000096 33 c1 xor eax , ecx 0 x00000098 4983 e901 sub r9 , 1 0 x0000009c 0 f856fffffff jne 0x11 0 x000000a2 c3 ret Although the exact cause is unknown, the ARM64 code regions are interpreted and executed as x64 code in the ARM64EC process. However, WinDbg refers to the Hybrid Code Map and disassembles as ARM64. Therefore, although the code can be executed, the disassembly view will be invalid.","title":"Fooling WinDbg"},{"location":"arm64x_reloc_obfuscation/#side-effect-parent-process-dependent-code-execution","text":"Finally, I would like to mention the side effect of the DVRT ARM64X relocation-based obfuscation. Recall that DVRT ARM64X relocation is only applied when ARM64X is executed as an ARM64EC or x64 process. The relocation is not applied if it is run as an ARM64 process. For ARM64X DLLs, DVRT ARM64X is applied when ARM64EC or x64 processes use them. However, what about ARM64X EXEs? Longhorn examined this, and the following table summarizes the results obtained by him. For ARM64X EXEs, the executed code in ARM64X depends on the parent process that runs it. Architecture of parent process Architecture of executed code x86 ARM64 x64 ARM64EC ARM64 ARM64 ARM64EC ARM64EC DVRT ARM64X relocation is applied only when the parent process architecture is ARM64EC or x64. This means that if the parent process architecture is x86 or ARM64, DVRT ARM64X relocation is not applied, and the ARM64 code in ARM64X is executed. Thus, ARM64X is a binary with different execution results depending on the architecture from which the parent process runs. This property can be exploited by attackers. For example, let us consider analyzing the ARM64X binary in a sandbox environment. ARM64X PE appears to be ARM64 PE through a simple static analysis (e.g., file type check by UNIX file command). Therefore, if you do not identify ARM64X, you might run it as an ARM64 PE and obtain the result of the dynamic analysis (despite the fact that ARM64EC actually contains malicious code!). When scrutinizing the results of dynamic analysis, it is necessary to check not only to look the results when running as an ARM64 but also the results when running as an ARM64EC.","title":"Side Effect: Parent-process-dependent code execution"},{"location":"arm64x_reloc_obfuscation/#conclusion","text":"In this article, we proposed the relocation-based obfuscation technique using DVRT ARM64X. As explained, relocation-based obfuscation techniques have been known for a long time. However, these techniques are now almost unusable because they rely on the image loader vulnerabilities that are currently fixed. With the introduction of DVRT ARM64X in Windows on ARM, relocation-based obfuscation can be used again for practical use. Since this technique does not rely on the vulnerabilities of the image loader, the proposed method can be used in Windows on ARM for a long time. I have also presented ideas to make the analysis of ARM64X more complicated and a side effect of the dependency of execution results on the parent process. Although some of these are not directly related to relocation-based obfuscation, they can be combined with the DVRT ARM64X obfuscation method to make analysis more difficult. Microsoft has not yet officially documented ARM64X, and there are not many reverse engineering results. Further research is required in this regard.","title":"Conclusion"},{"location":"new_reloc_chpev2/","text":"Discovering a new relocation entry of ARM64X in recent Windows 10 on Arm \u00b6 date: 2021/07/13 author: Koh M. Nakagawa Introduction \u00b6 Last December, Microsoft announced the x64 emulation for Windows 10 on Arm. This is excellent news for Windows 10 on Arm users because some applications are distributed as 64-bit-only x64 binaries. Now, they can use x64 apps with this x64 emulation feature. This news is exciting for me because I'm curious about the emulation technologies of Windows. Last year, at Black Hat EU 2020, I presented a new code injection technique in Windows 10 on Arm. During this research, I analyzed various binaries for x86 emulation ( xtajit.dll and xtac.exe ) and investigated how emulation works and some techniques used for speeding up x86 emulation (binary translation cache files and CHPE *). So, it was natural for me to examine the internals of the x64 emulation. * CHPE is a PE file containing both Arm64 and x86 code. This will be explained in more detail later. Digging into the x64 emulation, I discovered a new type of CHPE called CHPEV2 ARM64X. This CHPE has an intriguing property that it can be used by both x64 emulation processes and Arm64 native processes. Typically, the machine type in a DLL must match the architecture of the process loading it. If there is a mismatch, the DLL will not be loaded correctly. However, in CHPEV2 ARM64X, it can be loaded from both x64 emulation processes and Arm64 native processes! What makes it possible? To uncover this, I analyzed the CHPEV2 parser logic in the Windows kernel and found that a new relocation entry, IMAGE_DYNAMIC_RELOCATION_ARM64X makes this possible. This article explains the IMAGE_DYNAMIC_RELOCATION_ARM64X and how it makes CHPEV2 binaries loaded from both x64 and Arm64 processes. Compiled Hybrid PE (CHPE) \u00b6 First, let me explain CHPE to those of you who are unfamiliar with it. CHPE is a new type of PE file containing both x86 and Arm64 code for improving the performance of x86 emulation in Windows 10 on Arm. It looks like an x86 PE, that is, the machine type in IMAGE_NT_HEADERS of this PE is x86. When you disassemble an exported function, you will find x86 instruction sequences. However, following the instruction sequences, you will encounter the junk code block (see assembly instructions from 69edb530 in Figure 1). Figure 1 Disassembly listings of the MessageBoxA function. This junk code is actually Arm64 code (Figure 2). Figure 2 Disassembly listings of the code around the address 0x69edb530 by specifying Arm64 as the architecture. The purpose of this PE format is to reduce the amount of JIT translation. Typically, a function of an x86 PE is executed after translating the entire function to Arm64 code. However, in CHPE, only the function's prologue needs to be translated because the function body has already been translated. Why do prologues of functions exist as x86 code? As pointed out in the blog post , it is likely to maintain the backward compatibility of some applications using inline hooking. These applications modify the prologues of functions to inspect the argument values. Currently, Windows 10 on Arm provides some of the System DLLs as CHPEs, which are in the directory %SystemRoot%\\SysChpe32 . Some Microsoft Office binaries are also distributed as CHPEs. CHPEV2 \u00b6 One of the significant changes after the introduction of x64 emulation is that most DLLs previously built as Arm64 (e.g., DLLs in %SystemRoot%\\System32 ) are now CHPE. This script can be used to determine which of the system DLLs are CHPEs. In the following, I will refer to the new CHPE as CHPEV2 * (and the one in the previous section as simply CHPE). * I named \"CHPEV2\" from the string \"CHPEV2\" in the Windows Insider SDK header ( ksarm64.h ). CHPEV2 differs from the CHPE introduced in the previous section, based on the following points: It contains both x64 and Arm64 code (CHPE contains both x86 and Arm64 code). There are two types of CHPEV2: one has the Arm64 machine type, and the other has the x64 machine type in IMAGE_NT_HEADERS64 . CHPEV2 having the x64 machine type is called ARM64EC. CHPEV2 having the Arm64 architecture is called ARM64X. CHPEV2 ARM64EC is only used by x64 emulation processes. \"EC\" possibly stands for \"Emulation Compatible.\" Some system EXEs, such as PowerShell.exe , mmc.exe are CHPEV2 ARM64EC. CHPEV2 ARM64X is used by both x64 emulation processes and Arm64 native processes . It is a fat binary containing code for x64 emulation processes and code for Arm64 native processes. \"ARM64X is the resulting binary from linking ARM64 and ARM64EC objs and libs into one.\" Much of the system DLLs under %SystemRoot%\\System32 and some EXEs, such as cmd.exe , are CHPEV2 ARM64X. CHPEV2 ARM64EC is the x64 version of CHPE (i.e., it looks like an x64 PE but contains both x64 and Arm64 code), so is not-so-new. However, the CHPEV2 ARM64X is different. Of particular interest (as I said), CHPEV2 ARM64X DLLs can be loaded from x64 emulation processes, although they contain the Arm64 machine type. Typically, when the machine type in the loaded DLL is different from the architecture of the process, it will not be loaded correctly. However, in the case of the CHPEV2 built for ARM64X, these DLLs are loaded correctly. Moreover, we can find such strange behavior when we obtain the exported API addresses. For example, consider the following code. When building this source code by specifying x64 and Arm64 as the build targets and executing these EXE files, we obtain the following output (Figure 3). Figure 3 Console output of x64 process (top) and Arm64 process (bottom) The exported address differs between the execution by the x64 emulation process and the execution by the Arm64 native process. Analyzing this user32.dll statically, we can find two MessageBoxA functions ( #MessageBoxA for x64 and MessageBoxA for Arm64), as shown in Figure 4. Figure 4 Disassembly listings of the #MessageBoxA function called by the x64 emulation process (left) and the MessageBoxA function called by the Arm64 native process (right). This CHPEV2 ARM64X binary appears to change its machine type and export functions according to the architecture information of the process that uses it. What makes these possible? The answer to the question is the existence of a dynamic patch by a new relocation entry called IMAGE_DYNAMIC_RELOCATION_ARM64X . New Dynamic Value Relocation Table (DVRT): IMAGE_DYNAMIC_RELOCATION_ARM64X \u00b6 IMAGE_DYNAMIC_RELOCATION_ARM64X exists following the base relocation block in the .reloc section and has been added as a new type of Dynamic Value Relocation Table (DVRT) *. This relocation entry is applied from the kernel side by calling nt!MiApplyConditionalFixups . When the patch is applied, various information such as architecture information and an offset of Export Address Table (EAT) are overwritten at runtime. * DVRT is a relocation entry introduced to apply mitigation techniques such as Return Flow Guard (RFG) and retpoline at runtime. It overwrites a part of the code area at runtime to enable these mitigation techniques. For more details, see Tencent Security Xuanwu Lab blog post and Microsoft blog post . Now let's look at the data structure of IMAGE_DYNAMIC_RELOCATION_ARM64X . Figure 5 shows a schematic diagram of the IMAGE_DYNAMIC_RELOCATION_ARM64X data structure. Figure 5 Schematic picture of the structure of IMAGE_DYNAMIC_RELOCATION_ARM64X First, the DVRT header ( IMAGE_DYNAMIC_RELOCATION_TABLE ) is followed by the header of the IMAGE_DYNAMIC_RELOCATION_ARM64X table (called IMAGE_DYNAMIC_RELOCATION_ARM64X_HEADER ). The table consists of several blocks specified by the IMAGE_DYNAMIC_RELOCATION_ARM64X_BLOCK structure. There is one block per page to which the relocation is applied, and the VirtualAddress of IMAGE_DYNAMIC_RELOCATION_ARM64X_BLOCK contains the page RVA. The member Entries is an array whose element size is variable (the size of each element is at least two bytes). The first two bytes of data of each component is represented by the following MetadataAndOffset structure, where the offset is an offset from the starting address specified in the page RVA for the block, and meta contains the relocation type and other metadata (sign or scale index). The lower two bits of meta specify the relocation type. There are three types of relocations. Next, I will explain the data structure for each relocation type. Relocation type 1: zero fill ( meta & 0b11 == 0b00 ) This entry is used to clear the data at the target address to zero. The size is 2^x bytes, where x is the upper two bits of meta . The following C code illustrates how this relocation entry is applied. Relocation type 2: assign value ( meta & 0b11 == 0b01 ) This entry is used to overwrite the data in the target address with a specified value. The size to be written is encoded in meta in the same manner as for \"zero fill\". In this relocation entry, MetadataAndOffset is followed by data whose size is 2^x bytes, and this data is overwritten to the target address. The following pseudocode illustrates how this relocation entry is applied. Relocation type 3: add (or sub) delta ( meta & 0b11 == 0b10 ) This is an entry to add (or subtract) an offset in multiples of four (or eight) to the data in the target address. The scale factor and offset sign are encoded in the upper two bits of the meta , as shown below. meta[3] (scale) meta[2] (sign) 8 (for 1) 4 (for 0) minus (for 1) plus (for 0) In this relocation entry, MetadataAndOffset is followed by two bytes of data. This value multiplied by the scale factor is added (or subtracted) to the data in the target address. Example: user32.dll \u00b6 Let's look at what data are overwritten after relocations of IMAGE_DYNAMIC_RELOCATION_ARM64X are applied. Here, I take user32.dll as an example of CHPEV2 ARM64X. The DVRT of the user32.dll is shown in Figure 6. This figure shows only the block whose VirtualAddress value is 0 in IMAGE_DYNAMIC_RELOCATION_ARM64X . Figure 6 IMAGE_DYNAMIC_RELOCATION_ARM64X of user32.dll The first record (marked #0 in Figure 6) has a meta | offset value of 0x50ec ( meta is 0x5 and offset is 0xec ). According to the value of meta , the type of this relocation is \"assign value\" (the lower two bits are 0b01 ), and its size is two bytes (upper two bits are 0b01 ). Therefore, this relocation entry means that the data at 0x1800000ec (where the image base is 0x180000000 ) is overwritten with 0x8664 . Now, when you look at 0x1800000ec , you can find that it points to the IMAGE_NT_HEADERS64.IMAGE_FILE_HEADER.Machine (Figure 7). Figure 7 Listing view of user32.dll Hence, after the dynamic patch of this relocation entry is applied, the machine type in IMAGE_NT_HEADERS64 is changed from AArch64 ( 0xaa64 ) to x86_64 ( 0x8664 ). This is why the same DLL can be used by both the x64 emulation process and the Arm64 native process. When ARM64X binaries are loaded by x64 emulation processes, the machine type is dynamically written by this relocation entry, so there is no mismatch in the architecture information. Next, I will explain why the address of the EAT entry looks different between the x64 and Arm64 processes. Let's look at entry #1 in Figure 6. By Interpreting the relocation entry in the same manner as #0, we find that the four bytes of the data at address 0x180000170 will be overwritten with 0x144090 . When you look at the code at 0x180000170 , you find that it points to the VirtualAddress of IMAGE_DIRECTORY_ENTRY_EXPORT (Figure 8). Figure 8 Listing view of user32.dll So, after the dynamic patch of this relocation entry is applied, the VirtualAddress value is overwritten with 0x144090 . Let's look at the data at 0x144090 from the image base address ( 0x180000000 ). Another EAT can be found here (Figure 9). Thus, CHPEV2 ARM64X has two EATs for the x64 and Arm64 processes. Figure 9 Another EAT entry in user32.dll These two entries are switched depending on whether or not this relocation entry is applied. That's why CHPEV2 ARM64X changes its behavior depending on the architectures of processes using them. Visual Studio 2019 support of CHPEV2 \u00b6 There is no build tool available for CHPE, but Microsoft's internal MSVC allows it to be specified as a target . On the contrary, the build tool for CHPEV2 has been released to the public according to the release notes of Visual Studio 2019. https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes#--visual-studio-2019-version-1691 So, you can build your own ARM64EC and ARM64X binaries using the latest version of Visual Studio 2019. Conclusion \u00b6 In this article, I have explained what CHPEV2 is and a new relocation entry, IMAGE_DYNAMIC_RELOCATION_ARM64X in CHPEV2 ARM64X. We saw that the dynamic patch by this relocation entry makes it possible for CHPEV2 ARM64X to be used by both the x64 emulation processes and native Arm64 processes. CHPEV2 has many other interesting properties (such as a64xrm section, IAT Fast Forwarding, and Auxiliary IAT), which are not covered in this post. I'll cover these topics in future posts. Tools for analyzing ARM64X binaries are available in this repository. Please check it out. Additional notes \u00b6 Very recently, Microsoft officially announced CHPEV2 ARM64EC in their blog post . Details of CHPEV2 ARM64X are not included, but I think that its details might be announced soon.","title":"Discovering a new relocation entry of ARM64X in recent Windows 10 on Arm"},{"location":"new_reloc_chpev2/#discovering-a-new-relocation-entry-of-arm64x-in-recent-windows-10-on-arm","text":"date: 2021/07/13 author: Koh M. Nakagawa","title":"Discovering a new relocation entry of ARM64X in recent Windows 10 on Arm"},{"location":"new_reloc_chpev2/#introduction","text":"Last December, Microsoft announced the x64 emulation for Windows 10 on Arm. This is excellent news for Windows 10 on Arm users because some applications are distributed as 64-bit-only x64 binaries. Now, they can use x64 apps with this x64 emulation feature. This news is exciting for me because I'm curious about the emulation technologies of Windows. Last year, at Black Hat EU 2020, I presented a new code injection technique in Windows 10 on Arm. During this research, I analyzed various binaries for x86 emulation ( xtajit.dll and xtac.exe ) and investigated how emulation works and some techniques used for speeding up x86 emulation (binary translation cache files and CHPE *). So, it was natural for me to examine the internals of the x64 emulation. * CHPE is a PE file containing both Arm64 and x86 code. This will be explained in more detail later. Digging into the x64 emulation, I discovered a new type of CHPE called CHPEV2 ARM64X. This CHPE has an intriguing property that it can be used by both x64 emulation processes and Arm64 native processes. Typically, the machine type in a DLL must match the architecture of the process loading it. If there is a mismatch, the DLL will not be loaded correctly. However, in CHPEV2 ARM64X, it can be loaded from both x64 emulation processes and Arm64 native processes! What makes it possible? To uncover this, I analyzed the CHPEV2 parser logic in the Windows kernel and found that a new relocation entry, IMAGE_DYNAMIC_RELOCATION_ARM64X makes this possible. This article explains the IMAGE_DYNAMIC_RELOCATION_ARM64X and how it makes CHPEV2 binaries loaded from both x64 and Arm64 processes.","title":"Introduction"},{"location":"new_reloc_chpev2/#compiled-hybrid-pe-chpe","text":"First, let me explain CHPE to those of you who are unfamiliar with it. CHPE is a new type of PE file containing both x86 and Arm64 code for improving the performance of x86 emulation in Windows 10 on Arm. It looks like an x86 PE, that is, the machine type in IMAGE_NT_HEADERS of this PE is x86. When you disassemble an exported function, you will find x86 instruction sequences. However, following the instruction sequences, you will encounter the junk code block (see assembly instructions from 69edb530 in Figure 1). Figure 1 Disassembly listings of the MessageBoxA function. This junk code is actually Arm64 code (Figure 2). Figure 2 Disassembly listings of the code around the address 0x69edb530 by specifying Arm64 as the architecture. The purpose of this PE format is to reduce the amount of JIT translation. Typically, a function of an x86 PE is executed after translating the entire function to Arm64 code. However, in CHPE, only the function's prologue needs to be translated because the function body has already been translated. Why do prologues of functions exist as x86 code? As pointed out in the blog post , it is likely to maintain the backward compatibility of some applications using inline hooking. These applications modify the prologues of functions to inspect the argument values. Currently, Windows 10 on Arm provides some of the System DLLs as CHPEs, which are in the directory %SystemRoot%\\SysChpe32 . Some Microsoft Office binaries are also distributed as CHPEs.","title":"Compiled Hybrid PE (CHPE)"},{"location":"new_reloc_chpev2/#chpev2","text":"One of the significant changes after the introduction of x64 emulation is that most DLLs previously built as Arm64 (e.g., DLLs in %SystemRoot%\\System32 ) are now CHPE. This script can be used to determine which of the system DLLs are CHPEs. In the following, I will refer to the new CHPE as CHPEV2 * (and the one in the previous section as simply CHPE). * I named \"CHPEV2\" from the string \"CHPEV2\" in the Windows Insider SDK header ( ksarm64.h ). CHPEV2 differs from the CHPE introduced in the previous section, based on the following points: It contains both x64 and Arm64 code (CHPE contains both x86 and Arm64 code). There are two types of CHPEV2: one has the Arm64 machine type, and the other has the x64 machine type in IMAGE_NT_HEADERS64 . CHPEV2 having the x64 machine type is called ARM64EC. CHPEV2 having the Arm64 architecture is called ARM64X. CHPEV2 ARM64EC is only used by x64 emulation processes. \"EC\" possibly stands for \"Emulation Compatible.\" Some system EXEs, such as PowerShell.exe , mmc.exe are CHPEV2 ARM64EC. CHPEV2 ARM64X is used by both x64 emulation processes and Arm64 native processes . It is a fat binary containing code for x64 emulation processes and code for Arm64 native processes. \"ARM64X is the resulting binary from linking ARM64 and ARM64EC objs and libs into one.\" Much of the system DLLs under %SystemRoot%\\System32 and some EXEs, such as cmd.exe , are CHPEV2 ARM64X. CHPEV2 ARM64EC is the x64 version of CHPE (i.e., it looks like an x64 PE but contains both x64 and Arm64 code), so is not-so-new. However, the CHPEV2 ARM64X is different. Of particular interest (as I said), CHPEV2 ARM64X DLLs can be loaded from x64 emulation processes, although they contain the Arm64 machine type. Typically, when the machine type in the loaded DLL is different from the architecture of the process, it will not be loaded correctly. However, in the case of the CHPEV2 built for ARM64X, these DLLs are loaded correctly. Moreover, we can find such strange behavior when we obtain the exported API addresses. For example, consider the following code. When building this source code by specifying x64 and Arm64 as the build targets and executing these EXE files, we obtain the following output (Figure 3). Figure 3 Console output of x64 process (top) and Arm64 process (bottom) The exported address differs between the execution by the x64 emulation process and the execution by the Arm64 native process. Analyzing this user32.dll statically, we can find two MessageBoxA functions ( #MessageBoxA for x64 and MessageBoxA for Arm64), as shown in Figure 4. Figure 4 Disassembly listings of the #MessageBoxA function called by the x64 emulation process (left) and the MessageBoxA function called by the Arm64 native process (right). This CHPEV2 ARM64X binary appears to change its machine type and export functions according to the architecture information of the process that uses it. What makes these possible? The answer to the question is the existence of a dynamic patch by a new relocation entry called IMAGE_DYNAMIC_RELOCATION_ARM64X .","title":"CHPEV2"},{"location":"new_reloc_chpev2/#new-dynamic-value-relocation-table-dvrt-image_dynamic_relocation_arm64x","text":"IMAGE_DYNAMIC_RELOCATION_ARM64X exists following the base relocation block in the .reloc section and has been added as a new type of Dynamic Value Relocation Table (DVRT) *. This relocation entry is applied from the kernel side by calling nt!MiApplyConditionalFixups . When the patch is applied, various information such as architecture information and an offset of Export Address Table (EAT) are overwritten at runtime. * DVRT is a relocation entry introduced to apply mitigation techniques such as Return Flow Guard (RFG) and retpoline at runtime. It overwrites a part of the code area at runtime to enable these mitigation techniques. For more details, see Tencent Security Xuanwu Lab blog post and Microsoft blog post . Now let's look at the data structure of IMAGE_DYNAMIC_RELOCATION_ARM64X . Figure 5 shows a schematic diagram of the IMAGE_DYNAMIC_RELOCATION_ARM64X data structure. Figure 5 Schematic picture of the structure of IMAGE_DYNAMIC_RELOCATION_ARM64X First, the DVRT header ( IMAGE_DYNAMIC_RELOCATION_TABLE ) is followed by the header of the IMAGE_DYNAMIC_RELOCATION_ARM64X table (called IMAGE_DYNAMIC_RELOCATION_ARM64X_HEADER ). The table consists of several blocks specified by the IMAGE_DYNAMIC_RELOCATION_ARM64X_BLOCK structure. There is one block per page to which the relocation is applied, and the VirtualAddress of IMAGE_DYNAMIC_RELOCATION_ARM64X_BLOCK contains the page RVA. The member Entries is an array whose element size is variable (the size of each element is at least two bytes). The first two bytes of data of each component is represented by the following MetadataAndOffset structure, where the offset is an offset from the starting address specified in the page RVA for the block, and meta contains the relocation type and other metadata (sign or scale index). The lower two bits of meta specify the relocation type. There are three types of relocations. Next, I will explain the data structure for each relocation type. Relocation type 1: zero fill ( meta & 0b11 == 0b00 ) This entry is used to clear the data at the target address to zero. The size is 2^x bytes, where x is the upper two bits of meta . The following C code illustrates how this relocation entry is applied. Relocation type 2: assign value ( meta & 0b11 == 0b01 ) This entry is used to overwrite the data in the target address with a specified value. The size to be written is encoded in meta in the same manner as for \"zero fill\". In this relocation entry, MetadataAndOffset is followed by data whose size is 2^x bytes, and this data is overwritten to the target address. The following pseudocode illustrates how this relocation entry is applied. Relocation type 3: add (or sub) delta ( meta & 0b11 == 0b10 ) This is an entry to add (or subtract) an offset in multiples of four (or eight) to the data in the target address. The scale factor and offset sign are encoded in the upper two bits of the meta , as shown below. meta[3] (scale) meta[2] (sign) 8 (for 1) 4 (for 0) minus (for 1) plus (for 0) In this relocation entry, MetadataAndOffset is followed by two bytes of data. This value multiplied by the scale factor is added (or subtracted) to the data in the target address.","title":"New Dynamic Value Relocation Table (DVRT): IMAGE_DYNAMIC_RELOCATION_ARM64X"},{"location":"new_reloc_chpev2/#example-user32dll","text":"Let's look at what data are overwritten after relocations of IMAGE_DYNAMIC_RELOCATION_ARM64X are applied. Here, I take user32.dll as an example of CHPEV2 ARM64X. The DVRT of the user32.dll is shown in Figure 6. This figure shows only the block whose VirtualAddress value is 0 in IMAGE_DYNAMIC_RELOCATION_ARM64X . Figure 6 IMAGE_DYNAMIC_RELOCATION_ARM64X of user32.dll The first record (marked #0 in Figure 6) has a meta | offset value of 0x50ec ( meta is 0x5 and offset is 0xec ). According to the value of meta , the type of this relocation is \"assign value\" (the lower two bits are 0b01 ), and its size is two bytes (upper two bits are 0b01 ). Therefore, this relocation entry means that the data at 0x1800000ec (where the image base is 0x180000000 ) is overwritten with 0x8664 . Now, when you look at 0x1800000ec , you can find that it points to the IMAGE_NT_HEADERS64.IMAGE_FILE_HEADER.Machine (Figure 7). Figure 7 Listing view of user32.dll Hence, after the dynamic patch of this relocation entry is applied, the machine type in IMAGE_NT_HEADERS64 is changed from AArch64 ( 0xaa64 ) to x86_64 ( 0x8664 ). This is why the same DLL can be used by both the x64 emulation process and the Arm64 native process. When ARM64X binaries are loaded by x64 emulation processes, the machine type is dynamically written by this relocation entry, so there is no mismatch in the architecture information. Next, I will explain why the address of the EAT entry looks different between the x64 and Arm64 processes. Let's look at entry #1 in Figure 6. By Interpreting the relocation entry in the same manner as #0, we find that the four bytes of the data at address 0x180000170 will be overwritten with 0x144090 . When you look at the code at 0x180000170 , you find that it points to the VirtualAddress of IMAGE_DIRECTORY_ENTRY_EXPORT (Figure 8). Figure 8 Listing view of user32.dll So, after the dynamic patch of this relocation entry is applied, the VirtualAddress value is overwritten with 0x144090 . Let's look at the data at 0x144090 from the image base address ( 0x180000000 ). Another EAT can be found here (Figure 9). Thus, CHPEV2 ARM64X has two EATs for the x64 and Arm64 processes. Figure 9 Another EAT entry in user32.dll These two entries are switched depending on whether or not this relocation entry is applied. That's why CHPEV2 ARM64X changes its behavior depending on the architectures of processes using them.","title":"Example: user32.dll"},{"location":"new_reloc_chpev2/#visual-studio-2019-support-of-chpev2","text":"There is no build tool available for CHPE, but Microsoft's internal MSVC allows it to be specified as a target . On the contrary, the build tool for CHPEV2 has been released to the public according to the release notes of Visual Studio 2019. https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes#--visual-studio-2019-version-1691 So, you can build your own ARM64EC and ARM64X binaries using the latest version of Visual Studio 2019.","title":"Visual Studio 2019 support of CHPEV2"},{"location":"new_reloc_chpev2/#conclusion","text":"In this article, I have explained what CHPEV2 is and a new relocation entry, IMAGE_DYNAMIC_RELOCATION_ARM64X in CHPEV2 ARM64X. We saw that the dynamic patch by this relocation entry makes it possible for CHPEV2 ARM64X to be used by both the x64 emulation processes and native Arm64 processes. CHPEV2 has many other interesting properties (such as a64xrm section, IAT Fast Forwarding, and Auxiliary IAT), which are not covered in this post. I'll cover these topics in future posts. Tools for analyzing ARM64X binaries are available in this repository. Please check it out.","title":"Conclusion"},{"location":"new_reloc_chpev2/#additional-notes","text":"Very recently, Microsoft officially announced CHPEV2 ARM64EC in their blog post . Details of CHPEV2 ARM64X are not included, but I think that its details might be announced soon.","title":"Additional notes"}]}