
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-7.1.5">
    
    
      
        <title>Discovering a new relocation entry of ARM64X in recent Windows 10 on Arm - Project Chameleon</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.bde7dde4.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.ef6f36e2.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    <script>function __prefix(e){return new URL("..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#discovering-a-new-relocation-entry-of-arm64x-in-recent-windows-10-on-arm" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Project Chameleon" class="md-header__button md-logo" aria-label="Project Chameleon" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Project Chameleon
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Discovering a new relocation entry of ARM64X in recent Windows 10 on Arm
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/FFRI/ProjectChameleon/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Project Chameleon" class="md-nav__button md-logo" aria-label="Project Chameleon" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Project Chameleon
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/FFRI/ProjectChameleon/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Top page
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Discovering a new relocation entry of ARM64X in recent Windows 10 on Arm
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Discovering a new relocation entry of ARM64X in recent Windows 10 on Arm
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    Introduction
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#compiled-hybrid-pe-chpe" class="md-nav__link">
    Compiled Hybrid PE (CHPE)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chpev2" class="md-nav__link">
    CHPEV2
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#new-dynamic-value-relocation-table-dvrt-image_dynamic_relocation_arm64x" class="md-nav__link">
    New Dynamic Value Relocation Table (DVRT): IMAGE_DYNAMIC_RELOCATION_ARM64X
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#example-user32dll" class="md-nav__link">
    Example: user32.dll
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#visual-studio-2019-support-of-chpev2" class="md-nav__link">
    Visual Studio 2019 support of CHPEV2
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    Conclusion
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#additional-notes" class="md-nav__link">
    Additional notes
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    Introduction
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#compiled-hybrid-pe-chpe" class="md-nav__link">
    Compiled Hybrid PE (CHPE)
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chpev2" class="md-nav__link">
    CHPEV2
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#new-dynamic-value-relocation-table-dvrt-image_dynamic_relocation_arm64x" class="md-nav__link">
    New Dynamic Value Relocation Table (DVRT): IMAGE_DYNAMIC_RELOCATION_ARM64X
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#example-user32dll" class="md-nav__link">
    Example: user32.dll
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#visual-studio-2019-support-of-chpev2" class="md-nav__link">
    Visual Studio 2019 support of CHPEV2
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    Conclusion
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#additional-notes" class="md-nav__link">
    Additional notes
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/FFRI/ProjectChameleon/edit/main/docs_src/src/new_reloc_chpev2.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                <h1 id="discovering-a-new-relocation-entry-of-arm64x-in-recent-windows-10-on-arm">Discovering a new relocation entry of ARM64X in recent Windows 10 on Arm<a class="headerlink" href="#discovering-a-new-relocation-entry-of-arm64x-in-recent-windows-10-on-arm" title="Permanent link">&para;</a></h1>
<ul>
<li>date: 2021/07/13</li>
<li>author: Koh M. Nakagawa</li>
</ul>
<h2 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h2>
<p>Last December, Microsoft announced the x64 emulation for Windows 10 on Arm.
This is excellent news for Windows 10 on Arm users because some applications are distributed as 64-bit-only x64 binaries.
Now, they can use x64 apps with this x64 emulation feature.</p>
<p>This news is exciting for me because I'm curious about the emulation technologies of Windows.
Last year, at Black Hat EU 2020, I presented a new code injection technique in Windows 10 on Arm.
During this research, I analyzed various binaries for x86 emulation (<code>xtajit.dll</code> and <code>xtac.exe</code>) and investigated how emulation works and some techniques used for speeding up x86 emulation (binary translation cache files and CHPE *).
So, it was natural for me to examine the internals of the x64 emulation.</p>
<blockquote>
<p>* CHPE is a PE file containing both Arm64 and x86 code. This will be explained in more detail later.</p>
</blockquote>
<p>Digging into the x64 emulation, I discovered a new type of CHPE called CHPEV2 ARM64X.
This CHPE has an intriguing property that it can be used by both x64 emulation processes and Arm64 native processes.
Typically, the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types">machine type</a> in a DLL must match the architecture of the process loading it.
If there is a mismatch, the DLL will not be loaded correctly.
However, in CHPEV2 ARM64X, it can be loaded from both x64 emulation processes and Arm64 native processes!
What makes it possible?</p>
<p>To uncover this, I analyzed the CHPEV2 parser logic in the Windows kernel and found that a new relocation entry, <code>IMAGE_DYNAMIC_RELOCATION_ARM64X</code> makes this possible.
This article explains the <code>IMAGE_DYNAMIC_RELOCATION_ARM64X</code> and how it makes CHPEV2 binaries loaded from both x64 and Arm64 processes.</p>
<h2 id="compiled-hybrid-pe-chpe">Compiled Hybrid PE (CHPE)<a class="headerlink" href="#compiled-hybrid-pe-chpe" title="Permanent link">&para;</a></h2>
<p>First, let me explain CHPE to those of you who are unfamiliar with it.</p>
<p>CHPE is a new type of PE file containing both x86 and Arm64 code for improving the performance of x86 emulation in Windows 10 on Arm.
It looks like an x86 PE, that is, the machine type in <code>IMAGE_NT_HEADERS</code> of this PE is x86.
When you disassemble an exported function, you will find x86 instruction sequences.
However, following the instruction sequences, you will encounter the junk code block (see assembly instructions from <code>69edb530</code> in Figure 1).</p>
<figure>
    <img src="../assets/messageboxa_exportx86_to_body.png">
    <figcaption>Figure 1 Disassembly listings of the <code>MessageBoxA</code> function.</figcaption>
</figure>

<p>This junk code is actually Arm64 code (Figure 2).</p>
<figure>
    <img src="../assets/messageboxa_body_arm64.PNG" width="700">
    <figcaption>Figure 2 Disassembly listings of the code around the address <code>0x69edb530</code> by specifying Arm64 as the architecture.</figcaption>
</figure>

<p>The purpose of this PE format is to reduce the amount of JIT translation.
Typically, a function of an x86 PE is executed after translating the entire function to Arm64 code.
However, in CHPE, only the function's prologue needs to be translated because the function body has already been translated.</p>
<p>Why do prologues of functions exist as x86 code?
As pointed out in <a href="https://wbenny.github.io/2018/11/04/wow64-internals.html">the blog post</a>, it is likely to maintain the backward compatibility of some applications using inline hooking.
These applications modify the prologues of functions to inspect the argument values.</p>
<p>Currently, Windows 10 on Arm provides some of the System DLLs as CHPEs, which are in the directory <code>%SystemRoot%\SysChpe32</code>.
Some Microsoft Office binaries are also distributed as CHPEs.</p>
<h2 id="chpev2">CHPEV2<a class="headerlink" href="#chpev2" title="Permanent link">&para;</a></h2>
<p>One of the significant changes after the introduction of x64 emulation is that most DLLs previously built as Arm64 (e.g., DLLs in <code>%SystemRoot%\System32</code>) are now CHPE.
<a href="https://github.com/FFRI/ProjectChameleon/tree/master/chpe_scanner">This script</a> can be used to determine which of the system DLLs are CHPEs.
In the following, I will refer to the new CHPE as CHPEV2 * (and the one in the previous section as simply CHPE).</p>
<blockquote>
<p>* I named "CHPEV2" from the string "CHPEV2" in the Windows Insider SDK header (<code>ksarm64.h</code>).</p>
</blockquote>
<p>CHPEV2 differs from the CHPE introduced in the previous section, based on the following points:</p>
<ul>
<li>It contains both x64 and Arm64 code (CHPE contains both x86 and Arm64 code).</li>
<li>There are two types of CHPEV2: one has the Arm64 machine type, and the other has the x64 machine type in <code>IMAGE_NT_HEADERS64</code>.<ul>
<li>CHPEV2 having the x64 machine type is called ARM64EC.</li>
<li>CHPEV2 having the Arm64 architecture is called ARM64X.</li>
</ul>
</li>
<li>CHPEV2 ARM64EC is only used by x64 emulation processes.<ul>
<li>"EC" possibly stands for "Emulation Compatible."</li>
<li>Some system EXEs, such as <code>PowerShell.exe</code>, <code>mmc.exe</code> are CHPEV2 ARM64EC.</li>
</ul>
</li>
<li>CHPEV2 ARM64X is used by <strong>both x64 emulation processes and Arm64 native processes</strong>.<ul>
<li>It is a fat binary containing code for x64 emulation processes and code for Arm64 native processes.</li>
<li><a href="https://twitter.com/never_released/status/1371546800067346441">"ARM64X is the resulting binary from linking ARM64 and ARM64EC objs and libs into one."</a></li>
<li>Much of the system DLLs under <code>%SystemRoot%\System32</code> and some EXEs, such as <code>cmd.exe</code>, are CHPEV2 ARM64X.</li>
</ul>
</li>
</ul>
<p>CHPEV2 ARM64EC is the x64 version of CHPE (i.e., it looks like an x64 PE but contains both x64 and Arm64 code), so is not-so-new.</p>
<p>However, the CHPEV2 ARM64X is different.
Of particular interest (as I said), CHPEV2 ARM64X DLLs can be loaded from x64 emulation processes, although they contain the Arm64 machine type.</p>
<p>Typically, when the machine type in the loaded DLL is different from the architecture of the process, it will not be loaded correctly.
However, in the case of the CHPEV2 built for ARM64X, these DLLs are loaded correctly.</p>
<p>Moreover, we can find such strange behavior when we obtain the exported API addresses.
For example, consider the following code.</p>
<!--

<div class="codehilite"><pre><span></span><code><span class="cp">#include</span> <span class="cpf">&lt;Windows.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">HMODULE</span> <span class="n">baseAddr</span> <span class="o">=</span> <span class="n">LoadLibraryA</span><span class="p">(</span><span class="s">&quot;user32.dll&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">baseAddr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Image base address = %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">baseAddr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Image is not loaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;GetLastError() = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">PVOID</span> <span class="n">funcAddr</span> <span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">baseAddr</span><span class="p">,</span> <span class="s">&quot;MessageBoxA&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;MessageBoxA is located at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">funcAddr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>


-->

<figure>
    <img src="../assets/code1.PNG" width="600">
</figure>

<p>When building this source code by specifying x64 and Arm64 as the build targets and executing these EXE files, we obtain the following output (Figure 3).</p>
<figure>
    <img src="../assets/export_is_different.png" width="600">
    <figcaption>Figure 3 Console output of x64 process (top) and Arm64 process (bottom)</figcaption>
</figure>

<p>The exported address differs between the execution by the x64 emulation process and the execution by the Arm64 native process.
Analyzing this <code>user32.dll</code> statically, we can find two MessageBoxA functions (<code>#MessageBoxA</code> for x64 and <code>MessageBoxA</code> for Arm64), as shown in Figure 4.</p>
<figure>
    <img src="../assets/sharp_function_is_called.png">
    <figcaption>Figure 4 Disassembly listings of the <code>#MessageBoxA</code> function called by the x64 emulation process (left) and the <code>MessageBoxA</code> function called by the Arm64 native process (right).</figcaption>
</figure>

<p>This CHPEV2 ARM64X binary appears to change its machine type and export functions according to the architecture information of the process that uses it.</p>
<p>What makes these possible?
The answer to the question is the existence of a dynamic patch by a new relocation entry called <code>IMAGE_DYNAMIC_RELOCATION_ARM64X</code>.</p>
<h2 id="new-dynamic-value-relocation-table-dvrt-image_dynamic_relocation_arm64x">New Dynamic Value Relocation Table (DVRT): <code>IMAGE_DYNAMIC_RELOCATION_ARM64X</code><a class="headerlink" href="#new-dynamic-value-relocation-table-dvrt-image_dynamic_relocation_arm64x" title="Permanent link">&para;</a></h2>
<p><code>IMAGE_DYNAMIC_RELOCATION_ARM64X</code> exists following the base relocation block in the <code>.reloc</code> section and has been added as a new type of Dynamic Value Relocation Table (DVRT) *.
This relocation entry is applied from the kernel side by calling <code>nt!MiApplyConditionalFixups</code>.
When the patch is applied, various information such as architecture information and an offset of Export Address Table (EAT) are overwritten at runtime.</p>
<blockquote>
<p>* DVRT is a relocation entry introduced to apply mitigation techniques such as Return Flow Guard (RFG) and retpoline at runtime. It overwrites a part of the code area at runtime to enable these mitigation techniques. For more details, see <a href="https://xlab.tencent.com/en/2016/11/02/return-flow-guard/">Tencent Security Xuanwu Lab blog post</a> and <a href="https://techcommunity.microsoft.com/t5/windows-kernel-internals/mitigating-spectre-variant-2-with-retpoline-on-windows/ba-p/295618">Microsoft blog post</a>.</p>
</blockquote>
<p>Now let's look at the data structure of <code>IMAGE_DYNAMIC_RELOCATION_ARM64X</code>.</p>
<p>Figure 5 shows a schematic diagram of the <code>IMAGE_DYNAMIC_RELOCATION_ARM64X</code> data structure.</p>
<figure>
    <img src="../assets/schematic_picture_of_arm64x.png" width="700">
    <figcaption>Figure 5 Schematic picture of the structure of <code>IMAGE_DYNAMIC_RELOCATION_ARM64X</code> </figcaption>
</figure>

<p>First, the DVRT header (<code>IMAGE_DYNAMIC_RELOCATION_TABLE</code>) is followed by the header of the <code>IMAGE_DYNAMIC_RELOCATION_ARM64X</code> table (called <code>IMAGE_DYNAMIC_RELOCATION_ARM64X_HEADER</code>).
The table consists of several blocks specified by the <code>IMAGE_DYNAMIC_RELOCATION_ARM64X_BLOCK</code> structure.
There is one block per page to which the relocation is applied, and the <code>VirtualAddress</code> of <code>IMAGE_DYNAMIC_RELOCATION_ARM64X_BLOCK</code> contains the page RVA.</p>
<!--

<div class="codehilite"><pre><span></span><code><span class="k">struct</span> <span class="nc">IMAGE_DYNAMIC_RELOCATION_TABLE</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">Version</span><span class="p">;</span> <span class="c1">// always 1</span>
    <span class="n">DWORD</span> <span class="n">Size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">IMAGE_DYNAMIC_RELOCATION_ARM64X_HEADER</span> <span class="p">{</span>
    <span class="n">ULONGLONG</span> <span class="n">Symbol</span><span class="p">;</span> <span class="c1">// always 6</span>
    <span class="n">DWORD</span> <span class="n">FixupInfoSize</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">IMAGE_DYNAMIC_RELOCATION_ARM64X_BLOCK</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">VirtualAddress</span><span class="p">;</span> <span class="c1">// page RVA</span>
    <span class="n">DWORD</span> <span class="n">SizeOfBlock</span><span class="p">;</span>
    <span class="c1">// WORD Entries[1]; // three types of relocation entries exist</span>
<span class="p">};</span>
</code></pre></div>


-->

<figure>
    <img src="../assets/code2.PNG" width="600">
</figure>

<p>The member <code>Entries</code> is an array whose element size is variable (the size of each element is at least two bytes).
The first two bytes of data of each component is represented by the following <code>MetadataAndOffset</code> structure, where the <code>offset</code> is an offset from the starting address specified in the page RVA for the block, and <code>meta</code> contains the relocation type and other metadata (sign or scale index).</p>
<!--

<div class="codehilite"><pre><span></span><code><span class="k">typedef</span> <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">offset</span><span class="p">:</span> <span class="mi">12</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">meta</span><span class="p">:</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">field</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">raw</span><span class="p">;</span>
<span class="p">}</span> <span class="n">MetadataAndOffset</span><span class="p">;</span>
</code></pre></div>


-->

<figure>
    <img src="../assets/code3.PNG" width="300">
</figure>

<p>The lower two bits of <code>meta</code> specify the relocation type.
There are three types of relocations.
Next, I will explain the data structure for each relocation type.</p>
<p><strong>Relocation type 1: zero fill (<code>meta &amp; 0b11 == 0b00</code>)</strong></p>
<p>This entry is used to clear the data at the target address to zero.
The size is 2^x bytes, where x is the upper two bits of <code>meta</code>.
The following C code illustrates how this relocation entry is applied.</p>
<!--

<div class="codehilite"><pre><span></span><code><span class="c1">// VirtualAddress is the value of IMAGE_DYNAMIC_RELOCATION_ARM64X.VirtualAddress</span>
<span class="kt">void</span> <span class="nf">applyDVRTArm64X</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">ImageBase</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">VirtualAddress</span><span class="p">,</span> <span class="kt">uint16_t</span><span class="o">*</span> <span class="n">Entries</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">metaAndOffset</span> <span class="o">=</span> <span class="o">*</span><span class="n">Entries</span>
    <span class="kt">uint8_t</span> <span class="n">meta</span> <span class="o">=</span> <span class="p">(</span><span class="n">metaAndOffset</span> <span class="o">&amp;</span> <span class="mh">0xf000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">meta</span> <span class="o">&amp;</span> <span class="mb">0b11</span><span class="p">)</span> <span class="o">==</span> <span class="mb">0b00</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// zero fill entry</span>
        <span class="kt">uint32_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">meta</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mb">0b11</span><span class="p">);</span>
        <span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">metaAndOffset</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">targetAddr</span> <span class="o">=</span> <span class="n">ImageBase</span> <span class="o">+</span> <span class="n">VirtualAddress</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">uint16_t</span><span class="o">*</span><span class="p">)</span><span class="n">targetAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="n">targetAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">targetAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


-->
<figure>
    <img src="../assets/code4.PNG" width="700">
</figure>

<p><strong>Relocation type 2: assign value (<code>meta &amp; 0b11 == 0b01</code>)</strong></p>
<p>This entry is used to overwrite the data in the target address with a specified value.
The size to be written is encoded in <code>meta</code> in the same manner as for "zero fill".</p>
<p>In this relocation entry, <code>MetadataAndOffset</code> is followed by data whose size is 2^x bytes, and this data is overwritten to the target address.
The following pseudocode illustrates how this relocation entry is applied.</p>
<!--

<div class="codehilite"><pre><span></span><code><span class="c1">// VirtualAddress is the value of IMAGE_DYNAMIC_RELOCATION_ARM64X.VirtualAddress</span>
<span class="kt">void</span> <span class="nf">applyDVRTArm64X</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">ImageBase</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">VirtualAddress</span><span class="p">,</span> <span class="kt">uint16_t</span><span class="o">*</span> <span class="n">Entries</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">metaAndOffset</span> <span class="o">=</span> <span class="o">*</span><span class="n">Entries</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">meta</span> <span class="o">=</span> <span class="p">(</span><span class="n">metaAndOffset</span> <span class="o">&amp;</span> <span class="mh">0xf000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">meta</span> <span class="o">&amp;</span> <span class="mb">0b11</span><span class="p">)</span> <span class="o">==</span> <span class="mb">0b01</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// assign value entry</span>
        <span class="kt">uint32_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">meta</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mb">0b11</span><span class="p">);</span>
        <span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">metaAndOffset</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">targetAddr</span> <span class="o">=</span> <span class="n">ImageBase</span> <span class="o">+</span> <span class="n">VirtualAddress</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">srcAddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">Entries</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">uint16_t</span><span class="o">*</span><span class="p">)</span><span class="n">targetAddr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint16_t</span><span class="o">*</span><span class="p">)</span><span class="n">srcAddr</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="n">targetAddr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span><span class="n">srcAddr</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">targetAddr</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint64_t</span><span class="o">*</span><span class="p">)</span><span class="n">srcAddr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>


-->
<figure>
    <img src="../assets/code5.PNG" width="700">
</figure>

<p><strong>Relocation type 3: add (or sub) delta (<code>meta &amp; 0b11 == 0b10</code>)</strong></p>
<p>This is an entry to add (or subtract) an offset in multiples of four (or eight) to the data in the target address.
The scale factor and offset sign are encoded in the upper two bits of the <code>meta</code>, as shown below.</p>
<table>
<thead>
<tr>
<th align="center">meta[3] (scale)</th>
<th align="center">meta[2] (sign)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">8 (for 1) 4 (for 0)</td>
<td align="center">minus (for 1) plus (for 0)</td>
</tr>
</tbody>
</table>
<p>In this relocation entry, <code>MetadataAndOffset</code> is followed by two bytes of data.
This value multiplied by the scale factor is added (or subtracted) to the data in the target address.</p>
<!--

<div class="codehilite"><pre><span></span><code><span class="c1">// VirtualAddress is the value of IMAGE_DYNAMIC_RELOCATION_ARM64X.VirtualAddress</span>
<span class="kt">void</span> <span class="nf">applyDVRTArm64X</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">ImageBase</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">VirtualAddress</span><span class="p">,</span> <span class="kt">uint16_t</span><span class="o">*</span> <span class="n">Entries</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">metaAndOffset</span> <span class="o">=</span> <span class="o">*</span><span class="n">Entries</span><span class="p">;</span>
    <span class="kt">uint8_t</span> <span class="n">meta</span> <span class="o">=</span> <span class="p">(</span><span class="n">metaAndOffset</span> <span class="o">&amp;</span> <span class="mh">0xf000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">meta</span> <span class="o">&amp;</span> <span class="mb">0b11</span><span class="p">)</span> <span class="o">==</span> <span class="mb">0b10</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// add (or sub) delta</span>
        <span class="kt">uint32_t</span> <span class="n">scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">meta</span> <span class="o">&amp;</span> <span class="mb">0b1000</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span>  <span class="mi">8</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">sign</span>  <span class="o">=</span> <span class="p">(</span><span class="n">meta</span> <span class="o">&amp;</span> <span class="mb">0b0100</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">-1</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>

        <span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">metaAndOffset</span> <span class="o">&amp;</span> <span class="mh">0xfff</span><span class="p">;</span>
        <span class="kt">uint32_t</span> <span class="n">targetAddr</span> <span class="o">=</span> <span class="n">ImageBase</span> <span class="o">+</span> <span class="n">VirtualAddress</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
        <span class="kt">uint16_t</span> <span class="n">data</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">uint16_t</span><span class="o">*</span><span class="p">)((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">Entries</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>

        <span class="o">*</span><span class="p">(</span><span class="kt">int32_t</span><span class="o">*</span><span class="p">)</span><span class="n">targetAddr</span> <span class="o">+=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">scale</span> <span class="o">*</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div>


-->

<figure>
    <img src="../assets/code6.PNG" width="700">
</figure>

<h2 id="example-user32dll">Example: <code>user32.dll</code><a class="headerlink" href="#example-user32dll" title="Permanent link">&para;</a></h2>
<p>Let's look at what data are overwritten after relocations of <code>IMAGE_DYNAMIC_RELOCATION_ARM64X</code> are applied.
Here, I take <code>user32.dll</code> as an example of CHPEV2 ARM64X.</p>
<p>The DVRT of the <code>user32.dll</code> is shown in Figure 6.
This figure shows only the block whose <code>VirtualAddress</code> value is 0 in <code>IMAGE_DYNAMIC_RELOCATION_ARM64X</code>.</p>
<figure>
    <img src="../assets/DVRT_annotated.png" width="700">
    <figcaption>Figure 6 <code>IMAGE_DYNAMIC_RELOCATION_ARM64X</code> of <code>user32.dll</code> </figcaption>
</figure>

<p>The first record (marked #0 in Figure 6) has a <code>meta | offset</code> value of <code>0x50ec</code> (<code>meta</code> is <code>0x5</code> and <code>offset</code> is <code>0xec</code>).
According to the value of <code>meta</code>, the type of this relocation is "assign value" (the lower two bits are <code>0b01</code>), and its size is two bytes (upper two bits are <code>0b01</code>).
Therefore, this relocation entry means that the data at <code>0x1800000ec</code> (where the image base is <code>0x180000000</code>) is overwritten with <code>0x8664</code>.</p>
<p>Now, when you look at <code>0x1800000ec</code>, you can find that it points to the <code>IMAGE_NT_HEADERS64.IMAGE_FILE_HEADER.Machine</code> (Figure 7).</p>
<figure>
    <img src="../assets/ntheader_machine.PNG" width="700">
    <figcaption>Figure 7 Listing view of <code>user32.dll</code> </figcaption>
</figure>

<p>Hence, after the dynamic patch of this relocation entry is applied, the machine type in <code>IMAGE_NT_HEADERS64</code> is changed from AArch64 (<code>0xaa64</code>) to x86_64 (<code>0x8664</code>).</p>
<p>This is why the same DLL can be used by both the x64 emulation process and the Arm64 native process.
When ARM64X binaries are loaded by x64 emulation processes, the machine type is dynamically written by this relocation entry, so there is no mismatch in the architecture information.</p>
<p>Next, I will explain why the address of the EAT entry looks different between the x64 and Arm64 processes.
Let's look at entry #1 in Figure 6.
By Interpreting the relocation entry in the same manner as #0, we find that the four bytes of the data at address <code>0x180000170</code> will be overwritten with <code>0x144090</code>.
When you look at the code at <code>0x180000170</code>, you find that it points to the <code>VirtualAddress</code> of <code>IMAGE_DIRECTORY_ENTRY_EXPORT</code> (Figure 8).</p>
<figure>
    <img src="../assets/DATA_DIRECTORY_EXPORT.PNG">
    <figcaption>Figure 8 Listing view of <code>user32.dll</code> </figcaption>
</figure>

<p>So, after the dynamic patch of this relocation entry is applied, the <code>VirtualAddress</code> value is overwritten with <code>0x144090</code>.
Let's look at the data at <code>0x144090</code> from the image base address (<code>0x180000000</code>).
Another EAT can be found here (Figure 9).
Thus, CHPEV2 ARM64X has two EATs for the x64 and Arm64 processes.</p>
<figure>
    <img src="../assets/export_address_table_x64.PNG" width="600">
    <figcaption>Figure 9 Another EAT entry in <code>user32.dll</code></figcaption>
</figure>

<p>These two entries are switched depending on whether or not this relocation entry is applied.
That's why CHPEV2 ARM64X changes its behavior depending on the architectures of processes using them.</p>
<h2 id="visual-studio-2019-support-of-chpev2">Visual Studio 2019 support of CHPEV2<a class="headerlink" href="#visual-studio-2019-support-of-chpev2" title="Permanent link">&para;</a></h2>
<p>There is no build tool available for CHPE, but Microsoft's <a href="https://github.com/chakra-core/ChakraCore/search?q=CHPE&amp;unscoped_q=CHPE">internal MSVC allows it to be specified as a target</a>.</p>
<p>On the contrary, the build tool for CHPEV2 has been released to the public according to the release notes of Visual Studio 2019.</p>
<p><a href="https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes#--visual-studio-2019-version-1691">https://docs.microsoft.com/en-us/visualstudio/releases/2019/release-notes#--visual-studio-2019-version-1691</a></p>
<p>So, you can build your own ARM64EC and ARM64X binaries using the latest version of Visual Studio 2019.</p>
<h2 id="conclusion">Conclusion<a class="headerlink" href="#conclusion" title="Permanent link">&para;</a></h2>
<p>In this article, I have explained what CHPEV2 is and a new relocation entry, <code>IMAGE_DYNAMIC_RELOCATION_ARM64X</code> in CHPEV2 ARM64X.
We saw that the dynamic patch by this relocation entry makes it possible for CHPEV2 ARM64X to be used by both the x64 emulation processes and native Arm64 processes.</p>
<p>CHPEV2 has many other interesting properties (such as a64xrm section, IAT Fast Forwarding, and Auxiliary IAT), which are not covered in this post.
I'll cover these topics in future posts.</p>
<p>Tools for analyzing ARM64X binaries are available in this repository.
Please check it out.</p>
<h2 id="additional-notes">Additional notes<a class="headerlink" href="#additional-notes" title="Permanent link">&para;</a></h2>
<p>Very recently, Microsoft officially announced CHPEV2 ARM64EC in <a href="https://blogs.windows.com/windowsdeveloper/2021/06/28/announcing-arm64ec-building-native-and-interoperable-apps-for-windows-11-on-arm/">their blog post</a>.
Details of CHPEV2 ARM64X are not included, but I think that its details might be announced soon.</p>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <nav class="md-footer__inner md-grid" aria-label="Footer">
      
        <a href=".." class="md-footer__link md-footer__link--prev" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Top page
            </div>
          </div>
        </a>
      
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "../assets/javascripts/workers/search.d351de03.min.js", "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.a1609d9a.min.js"></script>
      
    
  </body>
</html>